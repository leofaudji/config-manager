<?php

/**
 * Class ChangelogParser
 * A dedicated parser for the CHANGELOG.md file to convert it into a structured HTML.
 */
class ChangelogParser
{
    /**
     * Parses the Markdown content of a changelog into a structured array.
     *
     * @param string $markdownContent The raw markdown content from CHANGELOG.md.
     * @return array A structured array representing the changelog versions and changes.
     */
    public static function parse(string $markdownContent): array
    {
        $lines = explode("\n", $markdownContent);
        $changelog = [];
        $currentVersion = null;
        $currentCategory = null;

        foreach ($lines as $line) {
            $line = trim($line);

            // Match version headers like "## [3.1.0] - 2023-10-29"
            if (preg_match('/^##\s+\[(.+?)\]\s+-\s+(.+)$/', $line, $matches)) {
                if ($currentVersion !== null) {
                    $changelog[] = $currentVersion;
                }
                $currentVersion = [
                    'version' => trim($matches[1]),
                    'date' => trim($matches[2]),
                    'changes' => []
                ];
                $currentCategory = null;
                continue;
            }

            // Match category headers like "### Added"
            if (preg_match('/^###\s+(.+)$/', $line, $matches)) {
                $currentCategory = trim($matches[1]);
                if ($currentVersion !== null && !isset($currentVersion['changes'][$currentCategory])) {
                    $currentVersion['changes'][$currentCategory] = [];
                }
                continue;
            }

            // Match list items (starts with '-', '*', or '+')
            if (preg_match('/^[-*+]\s+(.+)$/', $line, $matches)) {
                if ($currentVersion !== null && $currentCategory !== null) {
                    $changeText = trim($matches[1]);
                    // Recursively parse for nested lists
                    $currentVersion['changes'][$currentCategory][] = $changeText;
                }
            }
        }

        // Add the last processed version
        if ($currentVersion !== null) {
            $changelog[] = $currentVersion;
        }

        return $changelog;
    }

    /**
     * Gets the latest version number from the changelog file.
     *
     * @param string|null $filePath The path to the CHANGELOG.md file. If null, uses a default path.
     * @return string The latest version number, or a default if not found.
     */
    public static function getLatestVersion(?string $filePath = null): string
    {
        if ($filePath === null) {
            $filePath = PROJECT_ROOT . '/CHANGELOG.md';
        }

        if (!file_exists($filePath) || !is_readable($filePath)) {
            return '1.0.0'; // Fallback version
        }

        $handle = fopen($filePath, 'r');
        if ($handle) {
            while (($line = fgets($handle)) !== false) {
                if (preg_match('/^##\s+\[(.+?)\]/', $line, $matches)) {
                    fclose($handle);
                    return trim($matches[1]);
                }
            }
            fclose($handle);
        }
        return '1.0.0'; // Fallback if no version header is found
    }
    /**
     * Renders the structured changelog array into HTML.
     *
     * @param array $parsedChangelog The array generated by the parse() method.
     * @return string The final HTML string.
     */
    public static function renderHtml(array $parsedChangelog): string
    {
        if (empty($parsedChangelog)) {
            return '<p>No changelog entries found.</p>';
        }

        $html = '<div class="accordion" id="changelogAccordion">';
        $isFirst = true;

        foreach ($parsedChangelog as $versionEntry) {
            $versionSlug = 'v' . str_replace('.', '-', $versionEntry['version']);
            $collapseId = 'collapse-' . $versionSlug;
            $headingId = 'heading-' . $versionSlug;

            $html .= '<div class="accordion-item">';
            $html .= '<h2 class="accordion-header" id="' . $headingId . '">';
            $html .= '<button class="accordion-button' . ($isFirst ? '' : ' collapsed') . '" type="button" data-bs-toggle="collapse" data-bs-target="#' . $collapseId . '" aria-expanded="' . ($isFirst ? 'true' : 'false') . '" aria-controls="' . $collapseId . '">';
            $html .= '<span class="version-number">' . htmlspecialchars($versionEntry['version']) . '</span>&nbsp;<span class="text-muted small ms-2">- ' . htmlspecialchars($versionEntry['date']) . '</span>';
            $html .= '</button>';
            $html .= '</h2>';

            $html .= '<div id="' . $collapseId . '" class="accordion-collapse collapse' . ($isFirst ? ' show' : '') . '" aria-labelledby="' . $headingId . '" data-bs-parent="#changelogAccordion">';
            $html .= '<div class="accordion-body">';

            if (!empty($versionEntry['changes'])) {
                foreach ($versionEntry['changes'] as $category => $items) {
                    $categorySlug = strtolower(str_replace(' ', '-', $category));
                    $html .= '<h3 class="category-' . htmlspecialchars($categorySlug) . ' mt-3">' . htmlspecialchars($category) . '</h3>';
                    $html .= '<ul>';
                    foreach ($items as $item) {
                        // Simple inline markdown for `code` and **bold**
                        $itemHtml = preg_replace('/`([^`]+)`/', '<code>$1</code>', htmlspecialchars($item));
                        $itemHtml = preg_replace('/\*\*(.*?)\*\*/', '<strong>$1</strong>', $itemHtml);
                        $html .= '<li>' . $itemHtml . '</li>';
                    }
                    $html .= '</ul>';
                }
            }
            $html .= '</div></div></div>'; // Close accordion-body, accordion-collapse, accordion-item
            $isFirst = false;
        }

        $html .= '</div>'; // Close accordion
        return $html;
    }
}